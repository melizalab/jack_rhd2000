

* install notes

Linux and OS X don't need any additional USB drivers, although Linux needs a
rules file.

to compile the interface program from Intan, first run qmake, then make.

* rhythm api notes

consists of several classes. we're stuck with c++, though most of the
Intan-written classes are simple enough that the functionality could be lifted
into a pure C interface.

** okCFrontPanel

opal kelly interface. This library comes from Opal Kelly. Used to upload the
fpga bitfile. has some low-level memb functions for sending and receiving data.

The version I compiled doesn't seem to work, so I'll need to use the precompiled
versions shipped by Intan.

The linking is windows style, which means we statically link to some functions
in libokfrontpanel, but then call a method to load the dynamic library. This
means the sofile has to be in a known location.

** Rhd2000EvalBoard

this is the main high-level interface. configures the device, retrieves data.
owns the pointer to the okCFrontPanel object. essentially wraps common
communication tasks with the OK.

clarifications from the documentation follow:

there are 8 MISO input streams from RHD2000 chips, two per SPI cable. There are
8 available USB data streams.  Not all need to be enabled, which can reduce the
size of the USB packets and thus the latency.

there are 4 MOSI outputs to the RHD2000 chips. multiple chips can share the same
SPI bus but will receive the same commands.  Every sampling period, the FPGA
sends a series of commands through the MOSI bus.  The main command instructs the
chips to return ADC results from the three channels, and there can be up to
three additional commands.  Each auxiliary command produces an additional MISO
result, which due to some pipeline delays are the first three results in the
data frame.  The data streams are interleaved.

Each data frame has three aux commands, but we can upload sequences of commands
to be played in successive frames.  These sequences can repeat indefinitely in
their entirety or in part (or not at all).

Command sequences can be up to 1024 frames long, and there are RAM banks that
can hold up to 16 command sequences.  Different command sequences can be
assigned from these RAM banks to different ports.

The data frames also contain results from the ADCs on the eval board (up to 8
channels) and the TTL values.

No obvious way to stream data to the DACs, though one can redirect a channel
from an input data stream to the DAC for realtime monitoring. DAC values can be
set manually but maximal output rate is ~1 kHz. This means stimulus presentation
is going to require a sound card (or else some serious verilog reprogramming)

* jack considerations

the jack module will be pulling data off the opal kelly fifo.  to keep latency
low this fifo should be kept as empty as possible. we can report latency to the
jack system with jack_port_set_latency_range. latency estimates will also
include any transmission delays, etc.  we may need to update from time to time
based on the fill state of the fifo.

one potential major problem is that the rhd200EvalBoard class allocates memory
for incoming samples rather than putting them into a ringbuffer, so it's not
usable for realtime acquisition. It looks like I could potentially preallocate
the memory.

question of whether to implement as a plugin or a backend driver. Advantage of a
plugin is that it would work with both jack 1 and jack 2 without any
translation.  The driver may have more privileges (like being able to set the
sampling rate of the jack engine)

The intan can't be used for stimulus presentation, so in acute experiments we'll
also need a sound card. Jack2 appears to suport slaving multiple drivers, but
there's little documentation on this.  I think the alsa_out plugin is the way to
go.

http://www.trac.jackaudio.org/wiki/A_guide_to_the_Jack1_source_code
http://www.trac.jackaudio.org/wiki/A_guide_to_the_Jack2_source_code

Another consideration is how to support interactions with the eval board in
parallel to the jack acquisition. For example, setting amplifier bandwidths.
Some operations, like impedance testing, probably need to be executed outside of
JACK by separate programs. If multiple processes can communicate with the board,
then I could probably upload new commands while jack is running. Otherwise the
setup either needs to happen when starting the JACK driver, or beforehand.
Should probably see how intan's software handles this use case. Could just swipe
the impedance measurement and bandwidth code and implement as a separate
program.

Okay, looks like only one program can access the device at once.

* DONE write test connection program (test_driver)

connect to the opal kelly, upload the Rhythm bitfile, and flip some LEDs. I'm
using only the opal kelly class for this, to get a sense of how complex it is to
manipulate things directly

* DONE write test data collection program (test_stream)

This test program uses the Intan classes to connect to the device, scan for
amplifiers, and collect a bit of data.

The headstage-scanning code is fairly complex - it's lifted from mainwindow.cpp.
I'm leaving out the delay inference for now.

reading data a block at a time is way too slow.  probably need to pull more data
off the usb bus at a time to be efficient. Blocks are 60 frames.  Probably some
of this inefficiency is due to how data blocks are filled from the usb buffer.

* TODO design interface

The things we need to do with the eval board are:

1. get number of connected headstages
2. enable and disable spi ports
3. set sample rate
4. set headstage filtering parameters
5. impedance testing
6. stream data

The interface for the jack driver should be relatively simple - specify how many
ports to monitor and the sampling rate, at a minimum. Setting bandwidths could
be done at startup. Z testing should probably have its own application.  Indeed,
one could use the intan GUI to do this.

Q: should I use the intan c++ interface or just lift the commands from the
source? the interface is not very good, and doesn't actually provide much
abstraction. But the real reason to reimplement is to replace the datablock
class so we can stream the data more efficiently. The main culprits are
inefficient casting (convert char * array into ints manually) and some extra
copy operations.  Some copying is going to be necessary because of how the
channels are interleaved.  Another consequence is that if the FPGA software
changes, I'll have to update the implementation.  OTOH, if we want to hack that
code we'll have to maintain our own impl.

Some further testing reveals that pulling data off the usb bus one 60-frame
block at a time is much too slow.  This is a latency of 2 ms at 30 kHz.  The intan gui
is able to keep the fifo empty most of the time at 20 kHz, reading 12 blocks at
a time, so that means the latency is ~36 ms (or 720 frames).

I think I'm going to have to reimplement. Q: write a separate, testable
interface to the eval board, or just write a jack driver?  If a jack driver,
jack1 or jack2?


** base interface

base interfaces should encapsulate a lot, in my opinion, so they can be general.
a general daq interface should support starting and stopping, methods to query
the availability of data, and methods to query the capabilities of the device.
I'm not sure about whether a read() fxn is useful, because the format of the
data in memory will depend so much on the implementation.  read() could return a
void *, of course, though that's almost like not specifying an interface.

support changes to sampling rate? in principle this is okay, though it requires
colleciton to be stopped and the fifo to be flushed.  in practice there are some
complication related to regeneration of command sequences (see below)

a more general question is whether we should support dynamic reconfiguration of
the object.  If the interface is intended only for JACK drivers, the
configuration will always only happen once.

** rhd2000 eval implementation

a few tricky bits related to the aux command sequences.  setting the sampling
rate requires regeneration of the command sequences, both for the impedance
checking DAC and some registers on the amplifier.

I implemented this by setting sampling rate in the constructor for the eval
board and the amps - no need to support changes to it in a jack-based system.

** TODO interface for setting per-amplifier filter and amp power values

this means exposing the rhd2000 objects owned by rhd2000eval

** TODO data memory storage

data are copied out of the eval board's fifo in a fairly complex structure whose
sizes depend on the number of enabled data streams

: uint64_t header
: uint32_t frame
: short amp_data[32][nstreams]
: short aux_data[3][nstreams]
: short filler[nstreams]
: short adc_data[8]
: short ttl_in
: short ttl_out

The logic for dealing with this data include:

1) allocating a frame buffer of the appropriate size
2) traversing an array of frames
3) reading out elements across frames

However, essentially all we need to know is the size of a frame, which gives the
stride for reading data across frames.

There's a discrepancy between my interpretation of the spec and the code in
rhd2000datablock.cpp: specificially, the auxiliary data comes first in the MISO results
